请操作三个指针，得到真正的flag吧。

注意，本题data.in中的输入数据是按小端序给的（即低位字节在前），在x86的Windows环境中是可以正常运行，但在其它环境中不一定能保证正常运行。此题数据量不大，因此通过手操完成也是完全可行的。

在下发的pointer.c中，我们已经帮你完成了读入数据和输出数据的代码，你只需要正确完成每个指针的操作的代码即可。你可以添加任何你觉得有必要的函数或变量。

--------------输入格式--------------

第一行一个字符串flag，接下来你要操作指针对它修改得到flag。

第二行一个整数n，表示操作的次数。

接下来n行，每行三个整数id、step和data，对应一次操作，表示你应控制第id个指针，移动step步（正数向右，负数向左）后写入data。

初始时，所有指针均指向flag的开头。

--------------样例解释--------------

例如，你得到了以下输入：

abcdefghijklmnopqrstuvwxyz0123456789
3
0 0 48
1 1 589508969
2 1 2531906178181702433

一共三个操作：

第一个操作，使用ptr0（unsigned char类型），不用移动；此时ptr0指向flag开头的第一个字节，对应小写英文字母“a”，将其改为ASCII码为48的数字“0”。

第二个操作，使用ptr1（unsigned int类型），向右移动1步；注意unsigned int占用4个字节，所以移动后，ptr1指向的区域是flag第5~8个字符，即“efgh”这一部分；将data转换为16进制，得到0x23233169，按ASCII码转换得到“##1i”；注意，data是按小端序给的，低位字节在前，所以实际填进去的字符顺序是“i1##”。

第三个操作，使用ptr2（unsigned long long类型），向右移动1步；注意unsigned long long占用8个字节，所以移动后，ptr2指向的区域是flag第9~16个字符，即“ijklmnop”这一部分；将data转换为16进制，得到0x2323234123232321，按ASCII码转换得到“###A###!”；同样， 这也是按小端序给的，所以实际填进去的字符顺序是“!###A###”。

最终得到的字符串

0bcdi1##!###A###qrstuvwxyz0123456789

提交它即可。

以上为样例，并非此题最终答案。若对题意或样例仍有疑问，请与主办方联系。

始终牢记，本次比赛的flag恒以“ucatflags{”开头，以“}”结尾。